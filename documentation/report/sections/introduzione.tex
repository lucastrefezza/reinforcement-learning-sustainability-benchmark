\chapter{Introduzione}
Le \textit{espressioni regolari} sono uno degli argomenti principe della teoria della computazione. Dalla loro introduzione negli anni '50 da parte di Kleene~\cite{kleene:regexp} si sono sviluppate in maniera considerevole sia la teoria che le circonda che le applicazioni pratiche che le vedono protagoniste.

Questo duplice interesse nella materia ha provocato una scissione nel corso del tempo, che vede da un lato le espressioni regolari \textit{classiche}, come definite nella teoria della computazione e dei linguaggi formali, dall'altro un'ampia gamma di espressioni regolari \textit{pratiche}, proliferate nel corso del tempo insieme alle applicazioni ed ai linguaggi di scripting e/o programmazione che ne fanno uso, ognuna con diverse \textit{estensioni}.

La nomenclatura per questa nuova categoria di espressioni regolari è varia, nella pratica vengono spesso chiamate \textit{regexp} (dall'inglese \foreignlanguage{english}{\textit{regular expression}}, espressione regolare appunto), la letteratura a questo nome aggiunge \textit{espressioni regolari estese}, \textit{espressioni regolari pratiche} o \textit{rewbr} (acronimo di \textit{regular expression with backreference}). In questo lavoro utilizzeremo il termine \textit{espressioni regolari pratiche}, abbreviato in PRE, evitando il termine espressioni regolari estese, seppur più diffuso, per non generare confusione con le \textit{espressioni regolari generalizzate}~(\cite[vedi][399]{sipser:intro}).

Le estensioni, a cui si è finora solo accennato, si suddividono a loro volta in estensioni che preservano la regolarità dei linguaggi denotati delle espressioni regolari che ne fanno uso, ed in estensioni che invece aumentano il potere espressivo delle espressioni regolari classiche, estendendo la classe dei linguaggi da esse definiti oltre quella dei regolari.

Le estensioni che preservano la regolarità sono spesso indicate con il termine \foreignlanguage{english}{\textit{syntactic sugar}}, cioè letteralmente "zucchero sintattico", per indicare appunto di come si tratti di estensioni che sebbene agevolino la scrittura delle espressioni regolari da parte degli umani, non aggiungano potere espressivo alle stesse. Un esempio può essere riscontrato nelle espressioni regolari classiche, in cui viene a volte definito l'operatore $^+$ per indicare una o più ripetizioni del carattere che lo precede, più comodo nella stesura di un'espressione regolare, ma tranquillamente sostituibile da costrutti preesistenti, nello specifico $a^+$ è equivalente ad $aa^*$ (vedi sezione \ref{ch:espressioni_regolari}).

Non discuteremo oltre delle estensioni che si limitano ad essere del syntactic sugar, per concentrarci invece su quelle che estendono il potere espressivo delle espressioni regolari classiche. Tra queste la più famosa è indubbiamente la \textit{backreference}. Una backreference, come il nome suggerisce, è una \textit{referenza all'indietro}, cioè un modo per effettuare il match di una stringa di cui si è già precedentemente effettuato il match tramite una differente porzione dell'espressione regolare, cui si fa riferimento attraverso la backreference appunto. Nelle sezioni successive si approfondirà più dettagliatamente questo concetto (in particolare consultare la sezione \vref{sec:backreference} per una trattazione informale più approfondita, le successive per una definizione formale), per ora ci si limita a fornire un esempio.

Assumiamo l'alfabeto $\Sigma = \{a, b\}$ ed il linguaggio $L_1 = \{ a^nba^n \mid n \geq 0 \} $. Come ben noto il linguaggio $L_1$ non è regolare, quindi non è riconoscibile dalle espressioni regolari classiche. É tuttavia banalmente riconoscibile tramite l'utilizzo delle backreference, tramite la seguente espressione regolare: $(a^*)b\backslash1$.

In questo esempio il primo \textit{gruppo di cattura}, cioè ciò che è contenuto tra le due tonde, effettua il match di $a^*$, per poi \textit{memorizzare} la stringa di cui ha effettuato il match. A questo punto si prosegue come in una classica espressione regolare, con il match della $b$, per poi terminare con la backreference $\backslash1$. Questa fa riferimento al primo gruppo di cattura presente nell'espressione regolare, in questo caso l'unico, andrà quindi ad effettuare il match con ciò che è stato accoppiato da quest'ultimo, che, come accennato, è stato precedentemente memorizzato. L'espressione regolare pratica $(a^*)b\backslash1$ effettuerà il match quindi delle stringhe $b$, $aba$, $aabaa$ e così via.

Alle backreference si sono aggiunte nel corso del tempo varie altre estensioni come il \textit{forward reference}, i \textit{balancing group} (ad esempio in .NET), il \textit{lookaround} (a sua volta suddiviso in \textit{lookahead} e \textit{lookbehind}) ed addirittura in alcuni casi la ricorsione (come nelle espressioni regolari supportate da Perl, tra le più potenti). In questo lavoro ci concentreremo esclusivamente sulle backreference, tra le prime estensioni introdotte e già in grado di aumentare il potere espressivo delle espressioni regolari che ne fanno uso.

Nella sezione successiva si introdurranno alcune definizioni matematiche preliminari. In seguito, dopo aver trattato brevemente delle espressioni regolari classiche, si introdurrà la terminologia diffusasi nelle applicazioni pratiche delle espressioni regolari, che sarà utilizzata anche nel presente lavoro. Successivamente si esporranno alcuni tentativi di trattazione formale delle espressioni regolari pratiche, fino a giungere alla definizione proposta in questo lavoro.

Nel capitolo \ref{ch:automa} infine si proporrà una nuova tipologia di automa, detta \textit{automa a nastri}, in grado risconoscere la stessa classe di linguaggi definita dalle espressioni regolari pratiche, si concluderà il capitolo con una dimostrazione formale dell'equivalenza tra le PRE e gli automi a nastri.


\section{Definizioni Matematiche Preliminari}

In questa sezione si forniranno alcune definizioni matematiche che saranno utilizzate nel corso del lavoro, a partire dagli insiemi numerici. Definiamo l'insieme dei numeri naturali $\N$ come l'insieme dei numeri interi positivi, quindi $0$ escluso, cioè $\N = \{1, 2, 3, 4, 5, \dots\}$. Lo stesso insieme con l'inclusione dello $0$ sarà invece indicato con il simbolo $\Nz$, avremo quindi $\Nz = \N \cup \{0\} = \{0, 1, 2, 3, 4, 5, \dots\}$.

Nella teoria dei linguaggi formali, dato un alfabeto $\Sigma$, una stringa $w$ sul suddetto alfabeto, ed un simbolo $a \in \Sigma$, il numero di occorrenze di $a$ nella stringa $w$ è indicato con $\abs{w}_a$. Si estende la stessa definizione di occorrenze alle espressioni regolari, per cui dato un alfabeto $\Sigma$, un'espressione regolare $R$ su $\Sigma$, ed un simbolo $a \in \Sigma \cup \{(, )\}$, definiamo il numero di occorrenze di $a$ in $R$ come $\abs{R}_a$.

La parola vuota sarà indicata con il simbolo $\epsilon$.